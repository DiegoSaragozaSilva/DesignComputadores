<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <style>
  /* fundo para o trecho de código */
  div.sourceCode { overflow-x: auto; background-color: rgb(250,250,250);}
  
  /* Alinhamento dos títulos e parágrafos */
  
  body{margin-left: 5%; margin-right: 5%;
           color: black; background: white;}
  
  hr{
      margin-left: -4%;
      background-color: rgb(240,100,100);  /*Linha horizontal:    240,240,240 */
  }
  h1{
      margin-left: -4%;
      background-color: rgb(210,210,220);
  }
  
  h2{
      margin-left: -4%;
      background-color: rgb(220,220,230);
  }
  
  h3{
      margin-left: -4%;
      background-color: rgb(230,230,240);
  }
  
  h4{
      margin-left: -4%;
      background-color: rgb(240,240,250);
  }
  i{color: red}
  em{color: green}
  cite{color: brown}
  /* fundo para as linhas das tabelas */
  tr.even{
    background-color: rgb(250,250,255);
  }
  tr.odd{
    background-color: rgb(250,250,250);
  }
  </style>
</head>
<body>
<h1 id="exemplos-de-componentes-em-vhdl">Exemplos de Componentes em VHDL</h1>
<h2 id="combinacionais">Combinacionais</h2>
<h3 id="conversor-hexadecimal-para-sete-segmentos-display">Conversor Hexadecimal para Sete Segmentos (display)</h3>
<p>Pode ser necessário adicionar um registrador à entrada deste circuito.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">library</span> IEEE;
<span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">conversorHex7Seg</span> <span class="kw">is</span>
    <span class="kw">port</span>
    (
        <span class="co">-- Input ports</span>
        dadoHex <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic_vector</span>(<span class="dv">3</span> <span class="ot">downto</span> <span class="dv">0</span>);
        apaga   <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic</span> <span class="ot">:=</span> <span class="bn">&#39;0&#39;</span>;
        negativo <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic</span> <span class="ot">:=</span> <span class="bn">&#39;0&#39;</span>;
        overFlow <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic</span> <span class="ot">:=</span> <span class="bn">&#39;0&#39;</span>;
        <span class="co">-- Output ports</span>
        saida7seg <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>(<span class="dv">6</span> <span class="ot">downto</span> <span class="dv">0</span>)  <span class="co">-- := (others =&gt; &#39;1&#39;)</span>
    );
<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">comportamento</span> <span class="kw">of</span> <span class="kw">conversorHex7Seg</span> <span class="kw">is</span>
   <span class="co">--</span>
   <span class="co">--       0</span>
   <span class="co">--      ---</span>
   <span class="co">--     |   |</span>
   <span class="co">--    5|   |1</span>
   <span class="co">--     | 6 |</span>
   <span class="co">--      ---</span>
   <span class="co">--     |   |</span>
   <span class="co">--    4|   |2</span>
   <span class="co">--     |   |</span>
   <span class="co">--      ---</span>
   <span class="co">--       3</span>
   <span class="co">--</span>
    <span class="ot">signal</span> rascSaida7seg<span class="ot">:</span> <span class="dt">std_logic_vector</span>(<span class="dv">6</span> <span class="ot">downto</span> <span class="dv">0</span>);
<span class="kw">begin</span>
    rascSaida7seg <span class="ot">&lt;=</span>    <span class="st">&quot;1000000&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;0000&quot;</span> else <span class="co">---0</span>
                            <span class="st">&quot;1111001&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;0001&quot;</span> else <span class="co">---1</span>
                            <span class="st">&quot;0100100&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;0010&quot;</span> else <span class="co">---2</span>
                            <span class="st">&quot;0110000&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;0011&quot;</span> else <span class="co">---3</span>
                            <span class="st">&quot;0011001&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;0100&quot;</span> else <span class="co">---4</span>
                            <span class="st">&quot;0010010&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;0101&quot;</span> else <span class="co">---5</span>
                            <span class="st">&quot;0000010&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;0110&quot;</span> else <span class="co">---6</span>
                            <span class="st">&quot;1111000&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;0111&quot;</span> else <span class="co">---7</span>
                            <span class="st">&quot;0000000&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;1000&quot;</span> else <span class="co">---8</span>
                            <span class="st">&quot;0010000&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;1001&quot;</span> else <span class="co">---9</span>
                            <span class="st">&quot;0001000&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;1010&quot;</span> else <span class="co">---A</span>
                            <span class="st">&quot;0000011&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;1011&quot;</span> else <span class="co">---B</span>
                            <span class="st">&quot;1000110&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;1100&quot;</span> else <span class="co">---C</span>
                            <span class="st">&quot;0100001&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;1101&quot;</span> else <span class="co">---D</span>
                            <span class="st">&quot;0000110&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;1110&quot;</span> else <span class="co">---E</span>
                            <span class="st">&quot;0001110&quot;</span> <span class="kw">when</span> dadoHex<span class="ot">=</span><span class="st">&quot;1111&quot;</span> else <span class="co">---F</span>
                            <span class="st">&quot;1111111&quot;</span>; <span class="co">-- Apaga todos segmentos.</span>

    saida7seg <span class="ot">&lt;=</span>     <span class="st">&quot;1100010&quot;</span> <span class="kw">when</span> (overFlow<span class="ot">=</span><span class="bn">&#39;1&#39;</span>) else
                            <span class="st">&quot;1111111&quot;</span> <span class="kw">when</span> (apaga<span class="ot">=</span><span class="bn">&#39;1&#39;</span> <span class="kw">and</span> negativo<span class="ot">=</span><span class="bn">&#39;0&#39;</span>) else
                            <span class="st">&quot;0111111&quot;</span> <span class="kw">when</span> (apaga<span class="ot">=</span><span class="bn">&#39;0&#39;</span> <span class="kw">and</span> negativo<span class="ot">=</span><span class="bn">&#39;1&#39;</span>) else
                            rascSaida7seg;
<span class="er">end architecture;</span></code></pre></div>
<hr />
<h3 id="mux-genérico">MUX genérico</h3>
<h4 id="exemplo-de-código-para-o-mux">Exemplo de código para o MUX</h4>
<p>Abaixo temos o código para um multiplex de duas entradas.</p>
<p>A largura do barramento de entrada (e saída) é definida pela declaração do <em>generic</em>.</p>
<p><strong>Nome do arquivo: muxGenerico2.vhd</strong></p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">library</span> ieee;
<span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">muxGenerico2</span> <span class="kw">is</span>
    <span class="kw">generic</span> (
        <span class="co">-- Total de bits das entradas e saidas</span>
        larguraDados    <span class="ot">:</span> <span class="dt">natural</span>  <span class="ot">:=</span>   <span class="dv">8</span>
    );
    <span class="kw">port</span> (
        entradaA_MUX    <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic_vector</span>(larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
        entradaB_MUX    <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic_vector</span>(larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
        seletor_MUX   <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic</span>;

        saida_MUX   <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>(larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>)
    );
<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">comportamento</span> <span class="kw">of</span> <span class="kw">muxGenerico2</span> <span class="kw">is</span>
<span class="kw">begin</span>
  <span class="co">-- Para sintetizar lógica combinacional usando um processo,</span>
  <span class="co">--  todas as entradas do modulo devem aparecer na lista de sensibilidade.</span>
    <span class="kw">process</span>(entradaA_MUX<span class="ot">,</span> entradaB_MUX<span class="ot">,</span> seletor_MUX) <span class="kw">is</span>
    <span class="kw">begin</span>
     <span class="co">-- If é uma instrução sequencial que não pode ser usada</span>
     <span class="co">--  na seção de instruções concorrentes da arquitetura.</span>
        <span class="kw">if</span>(seletor_MUX<span class="ot">=</span><span class="bn">&#39;0&#39;</span>) <span class="kw">then</span>
            saida_MUX <span class="ot">&lt;=</span> entradaA_MUX;
        <span class="kw">else</span>
            saida_MUX <span class="ot">&lt;=</span> entradaB_MUX;
        <span class="kw">end if;</span>
    <span class="kw">end process</span>;
<span class="kw">end architecture;</span></code></pre></div>
<hr />
<h3 id="somador-genérico">Somador Genérico</h3>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">library</span> ieee;
<span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;
<span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;           <span class="co">--Soma (esta biblioteca =ieee)</span>

<span class="kw">entity</span> <span class="kw">somadorGenerico</span> <span class="kw">is</span>
    <span class="kw">generic</span>
    (
        larguraDados <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">32</span>
    );
    <span class="kw">port</span>
    (
        entradaA<span class="ot">,</span> entradaB<span class="ot">:</span> <span class="kw">in</span> <span class="dt">STD_LOGIC_VECTOR</span>((larguraDados<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
        saida<span class="ot">:</span>  <span class="kw">out</span> <span class="dt">STD_LOGIC_VECTOR</span>((larguraDados<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>)
    );
<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">comportamento</span> <span class="kw">of</span> <span class="kw">somadorGenerico</span> <span class="kw">is</span>
    <span class="kw">begin</span>
        saida <span class="ot">&lt;=</span> <span class="dt">STD_LOGIC_VECTOR</span>(<span class="dt">unsigned</span>(entradaA) <span class="ot">+</span> <span class="dt">unsigned</span>(entradaB));
<span class="er">end architecture;</span></code></pre></div>
<hr />
<h3 id="soma-com-constante-configurável">Soma com Constante Configurável</h3>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">library</span> ieee;
<span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;
<span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;  <span class="co">--Soma (esta biblioteca =ieee)</span>

<span class="kw">entity</span> <span class="kw">soma4</span> <span class="kw">is</span>
    <span class="kw">generic</span>
    (
        larguraDados <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">32</span>;
        incremento <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">4</span>
    );
    <span class="kw">port</span>
    (
        entrada<span class="ot">:</span> <span class="kw">in</span>  <span class="dt">STD_LOGIC_VECTOR</span>((larguraDados<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
        saida<span class="ot">:</span>   <span class="kw">out</span> <span class="dt">STD_LOGIC_VECTOR</span>((larguraDados<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>)
    );
<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">comportamento</span> <span class="kw">of</span> <span class="kw">soma4</span> <span class="kw">is</span>
    <span class="kw">begin</span>
        saida <span class="ot">&lt;=</span> <span class="dt">std_logic_vector</span>(<span class="dt">unsigned</span>(entrada) <span class="ot">+</span> incremento);
<span class="er">end architecture;</span></code></pre></div>
<hr />
<h3 id="extensor-de-sinal-genérico">Extensor de Sinal Genérico</h3>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">library</span> ieee;
<span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">estendeSinalGenerico</span> <span class="kw">is</span>
    <span class="kw">generic</span>
    (
        larguraDadoEntrada <span class="ot">:</span> <span class="dt">natural</span>  <span class="ot">:=</span>    <span class="dv">8</span>;
        larguraDadoSaida   <span class="ot">:</span> <span class="dt">natural</span>  <span class="ot">:=</span>    <span class="dv">8</span>
    );
    <span class="kw">port</span>
    (
        <span class="co">-- Input ports</span>
        estendeSinal_IN <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic_vector</span>(larguraDadoEntrada<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
        <span class="co">-- Output ports</span>
        estendeSinal_OUT<span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>(larguraDadoSaida<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>)
    );
<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">comportamento</span> <span class="kw">of</span> <span class="kw">estendeSinalGenerico</span> <span class="kw">is</span>
<span class="kw">begin</span>
    <span class="kw">process</span> (estendeSinal_IN) <span class="kw">is</span>
    <span class="kw">begin</span>
            <span class="kw">if</span> (estendeSinal_IN(larguraDadoEntrada<span class="ot">-</span><span class="dv">1</span>) <span class="ot">=</span> <span class="bn">&#39;1&#39;</span>) <span class="kw">then</span>
                estendeSinal_OUT <span class="ot">&lt;=</span> (larguraDadoSaida<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> larguraDadoEntrada <span class="ot">=&gt;</span> <span class="bn">&#39;1&#39;</span>) <span class="ot">&amp;</span> estendeSinal_IN;
            <span class="kw">else</span>
                estendeSinal_OUT <span class="ot">&lt;=</span> (larguraDadoSaida<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> larguraDadoEntrada <span class="ot">=&gt;</span> <span class="bn">&#39;0&#39;</span>) <span class="ot">&amp;</span> estendeSinal_IN;
            <span class="kw">end if;</span>
    <span class="kw">end process</span>;
<span class="kw">end architecture;</span></code></pre></div>
<hr />
<hr />
<h2 id="circuitos-sequenciais">Circuitos Sequenciais</h2>
<h3 id="detector-de-borda">Detector de Borda</h3>
<p>Nome do arquivo: edgeDetector.vhd</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span class="kw">library</span> IEEE;
<span class="kw">use</span> IEEE<span class="ot">.</span>STD_LOGIC_1164<span class="ot">.</span>ALL;

<span class="kw">entity</span> <span class="kw">edgeDetector</span> <span class="kw">is</span>
     <span class="kw">Port</span> ( clk     <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">STD_LOGIC</span>;
              entrada <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">STD_LOGIC</span>;
              saida   <span class="ot">:</span> <span class="kw">out</span> <span class="dt">STD_LOGIC</span>);
<span class="er">end entity;</span>

<span class="kw">architecture</span> <span class="kw">bordaSubida</span> <span class="kw">of</span> <span class="kw">edgeDetector</span> <span class="kw">is</span>
    <span class="ot">signal</span> saidaQ <span class="ot">:</span> <span class="dt">STD_LOGIC</span>;
<span class="kw">begin</span>
  <span class="kw">process</span>(clk)
  <span class="kw">begin</span>
        <span class="kw">if</span> <span class="kw">rising_edge</span>(clk) <span class="kw">then</span>
            saidaQ <span class="ot">&lt;=</span> entrada;
        <span class="kw">end if;</span>
  <span class="kw">end process</span>;
  saida <span class="ot">&lt;=</span> entrada <span class="kw">and</span> (<span class="kw">not</span> saidaQ);
<span class="er">end  architecture bordaSubida;</span>


<span class="kw">architecture</span> <span class="kw">bordaDescida</span> <span class="kw">of</span> <span class="kw">edgeDetector</span> <span class="kw">is</span>
    <span class="ot">signal</span> saidaQ <span class="ot">:</span> <span class="dt">STD_LOGIC</span>;
<span class="kw">begin</span>
  <span class="kw">process</span>(clk)
  <span class="kw">begin</span>
        <span class="kw">if</span> <span class="kw">rising_edge</span>(clk) <span class="kw">then</span>
            saidaQ <span class="ot">&lt;=</span> entrada;
        <span class="kw">end if;</span>
  <span class="kw">end process</span>;
  saida <span class="ot">&lt;=</span> (<span class="kw">not</span> entrada) <span class="kw">and</span> saidaQ;
<span class="er">end  architecture bordaDescida;</span></code></pre></div>
<h4 id="exemplo-de-uso">Exemplo de uso</h4>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
detectorSub0<span class="ot">:</span> work<span class="ot">.</span>edgeDetector(bordaSubida) port map (clk <span class="ot">=&gt;</span> CLOCK_50<span class="ot">,</span> entrada <span class="ot">=&gt;</span> (not KEY(0))<span class="ot">,</span> saida <span class="ot">=&gt;</span> auxReset);
detectorSub1<span class="ot">:</span> work<span class="ot">.</span>edgeDetector(bordaSubida) port map (clk <span class="ot">=&gt;</span> CLOCK_50<span class="ot">,</span> entrada <span class="ot">=&gt;</span> (not KEY(1))<span class="ot">,</span> saida <span class="ot">=&gt;</span> auxBt1);
detectorSub2<span class="ot">:</span> work<span class="ot">.</span>edgeDetector(bordaSubida) port map (clk <span class="ot">=&gt;</span> CLOCK_50<span class="ot">,</span> entrada <span class="ot">=&gt;</span> (not KEY(2))<span class="ot">,</span> saida <span class="ot">=&gt;</span> auxBt2);
detectorSub3<span class="ot">:</span> work<span class="ot">.</span>edgeDetector(bordaSubida) port map (clk <span class="ot">=&gt;</span> CLOCK_50<span class="ot">,</span> entrada <span class="ot">=&gt;</span> (not KEY(3))<span class="ot">,</span> saida <span class="ot">=&gt;</span> auxBt3);</code></pre></div>
<hr />
<h3 id="registrador-genérico">Registrador Genérico</h3>
<p>A largura dos dados (número de bits) é definida pelo <em>generic</em>.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">library</span> IEEE;
<span class="kw">use</span> IEEE<span class="ot">.</span>STD_LOGIC_1164<span class="ot">.</span>ALL;

<span class="kw">entity</span> <span class="kw">registradorGenerico</span> <span class="kw">is</span>
    <span class="kw">generic</span> (
        larguraDados <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>
    );
    <span class="kw">port</span> (DIN <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>(larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
       DOUT <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>(larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
       ENABLE <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
       CLK<span class="ot">,</span>RST <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>
        );
<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">comportamento</span> <span class="kw">of</span> <span class="kw">registradorGenerico</span> <span class="kw">is</span>
<span class="kw">begin</span>
    <span class="co">-- In Altera devices, register signals have a set priority.</span>
    <span class="co">-- The HDL design should reflect this priority.</span>
    <span class="kw">process</span>(RST<span class="ot">,</span> CLK)
    <span class="kw">begin</span>
        <span class="co">-- The asynchronous reset signal has the highest priority</span>
        <span class="kw">if</span> (RST <span class="ot">=</span> <span class="bn">&#39;1&#39;</span>) <span class="kw">then</span>
            DOUT <span class="ot">&lt;=</span> (<span class="ot">others</span> <span class="ot">=&gt;</span> <span class="bn">&#39;0&#39;</span>);    <span class="co">-- Código reconfigurável.</span>
        <span class="kw">else</span>
            <span class="co">-- At a clock edge, if asynchronous signals have not taken priority,</span>
            <span class="co">-- respond to the appropriate synchronous signal.</span>
            <span class="co">-- Check for synchronous reset, then synchronous load.</span>
            <span class="co">-- If none of these takes precedence, update the register output</span>
            <span class="co">-- to be the register input.</span>
            <span class="kw">if</span> (<span class="kw">rising_edge</span>(CLK)) <span class="kw">then</span>
                <span class="kw">if</span> (ENABLE <span class="ot">=</span> <span class="bn">&#39;1&#39;</span>) <span class="kw">then</span>
                        DOUT <span class="ot">&lt;=</span> DIN;
                <span class="kw">end if;</span>
            <span class="kw">end if;</span>
        <span class="kw">end if;</span>
    <span class="kw">end process</span>;
<span class="kw">end architecture;</span></code></pre></div>
<hr />
<h3 id="base-de-tempo">Base de tempo</h3>
<p>Para obter a referência de tempo para o relógio, é necessário dividir o <em>clock</em> de entrada por um valor X (inteiro) e obter a <em>saida_clk</em>.</p>
<p>Para tanto, pode-se utilizar o código do divisorGenerico, mostrado abaixo.</p>
<p>Em seguida ao código do divisor, temos um <a href="#topLevel">exemplo de uso (instanciação)</a>.</p>
<p>Para evitar problemas com o sincronismo desse <em>saida_clk</em> gerado, deve-se tomar cuidado com a sincronização.</p>
<p>O resultado do divisor pode ser usado para habilitar um <em>flip-flop</em> que <strong>executará uma divisão por dois sincronizada</strong> com o <em>clock</em>, como mostrado abaixo.</p>
<p>Em resumo, para obter uma base de tempo de um segundo:</p>
<pre><code>-   Faça a divisão do clock de entrada (CLOCK_50 do kit de desenvolvimento):

    -   Usando um contador até 25.000.000;

    -   E use a saída do contador para ativar um flip-flop que divide por 2;

    -   Assim, será obtido um sinal de 1 Hz, 50% de ciclo ativo e sincronizado com o clock do circuito.</code></pre>
<ul>
<li>O sinal <strong>clk</strong> do desenho deve ser conectado ao <strong>CLOCK_50</strong> da placa de FPGA.</li>
</ul>
<div class="figure">
<img src="../imagensVHDL/clockDomainSynchronizedPCFS.svg" />

</div>
<hr />
<h4 id="exemplo-de-código-para-o-divisor">Exemplo de código para o divisor</h4>
<p>Abaixo temos o código para um divisor que opera de três formas distintas:</p>
<ul>
<li><p>Dividindo por 2;</p></li>
<li><p>Dividindo por 2^(n+1);</p></li>
<li><p>Dividindo por um inteiro 2n.</p></li>
</ul>
<p>Onde &quot;n&quot; é o valor definido no <em>generic map</em>.</p>
<p><strong>Note que esse exemplo já possui uma divisão por 2 no fim da contagem, ou seja, ele deverá ser adaptado para funcionar como o desenho acima.</strong></p>
<p>Em seguida ao código do divisor, temos um <a href="#topLevel">exemplo de uso (instanciação)</a>.</p>
<p><strong>Nome do arquivo: divisorGenerico.vhd</strong></p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
   <span class="kw">LIBRARY</span> ieee;
   <span class="kw">USE</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>ALL;
   <span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;

   <span class="kw">entity</span> <span class="kw">divisorGenerico</span> <span class="kw">is</span>
    <span class="kw">generic</span>
    (divisor <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>);
       <span class="kw">port</span>(
           clk      <span class="ot">:</span>   <span class="kw">in</span> <span class="dt">std_logic</span>;
           saida_clk <span class="ot">:</span>   <span class="kw">out</span> <span class="dt">std_logic</span>
           );
   <span class="er">end entity;</span>

   <span class="co">-- Nao usa o valor do divisor. So divide por 2.</span>

   <span class="kw">architecture</span> <span class="kw">divPor2</span> <span class="kw">of</span> <span class="kw">divisorGenerico</span> <span class="kw">is</span>
       <span class="ot">signal</span> tick <span class="ot">:</span> <span class="dt">std_logic</span>;
   <span class="kw">begin</span>
       <span class="kw">process</span>(clk)
       <span class="kw">begin</span>
           <span class="kw">if</span> <span class="kw">rising_edge</span>(clk) <span class="kw">then</span>
               tick <span class="ot">&lt;=</span> <span class="kw">not</span> tick;
           <span class="kw">end if;</span>
       <span class="kw">end process</span>;
       saida_clk <span class="ot">&lt;=</span> tick;
   <span class="er">end architecture divPor2;</span>

   <span class="co">-- O valor &quot;n&quot; do divisor, define a divisao por 2^(n+1).</span>
   <span class="co">-- Ou seja, 2^n é metade do período da frequência de saída.</span>

   <span class="kw">architecture</span> <span class="kw">divPotenciaDe2</span> <span class="kw">of</span> <span class="kw">divisorGenerico</span> <span class="kw">is</span>
        <span class="ot">signal</span> contador <span class="ot">:</span> <span class="dt">std_logic_vector</span>(divisor <span class="ot">downto</span> <span class="dv">0</span>);
   <span class="kw">begin</span>
        <span class="kw">process</span>(clk)
        <span class="kw">begin</span>
            <span class="kw">if</span> <span class="kw">rising_edge</span>(clk) <span class="kw">then</span>
                contador <span class="ot">&lt;=</span> <span class="dt">std_logic_vector</span>(<span class="dt">unsigned</span>(contador) <span class="ot">+</span> <span class="dv">1</span>);
            <span class="kw">end if;</span>
        <span class="kw">end process</span>;
    saida_clk <span class="ot">&lt;=</span> contador(divisor);
   <span class="er">end architecture divPotenciaDe2;</span>

   <span class="co">-- O valor &quot;n&quot; do divisor, define a divisao por &quot;2n&quot;.</span>
   <span class="co">-- Ou seja, n é metade do período da frequência de saída.</span>

   <span class="kw">architecture</span> <span class="kw">divInteiro</span> <span class="kw">of</span> <span class="kw">divisorGenerico</span> <span class="kw">is</span>
        <span class="ot">signal</span> tick <span class="ot">:</span> <span class="dt">std_logic</span> <span class="ot">:=</span> <span class="bn">&#39;0&#39;</span>;
        <span class="ot">signal</span> contador <span class="ot">:</span> <span class="dt">integer</span> <span class="kw">range</span> <span class="dv">0</span> <span class="ot">to</span> divisor<span class="ot">+</span><span class="dv">1</span> <span class="ot">:=</span> <span class="dv">0</span>;
   <span class="kw">begin</span>
        <span class="kw">process</span>(clk)
        <span class="kw">begin</span>
            <span class="kw">if</span> <span class="kw">rising_edge</span>(clk) <span class="kw">then</span>
                <span class="kw">if</span> contador <span class="ot">=</span> divisor <span class="kw">then</span>
                    contador <span class="ot">&lt;=</span> <span class="dv">0</span>;
                    tick <span class="ot">&lt;=</span> <span class="kw">not</span> tick;
                <span class="kw">else</span>
                    contador <span class="ot">&lt;=</span> contador <span class="ot">+</span> <span class="dv">1</span>;
                <span class="kw">end if;</span>
            <span class="kw">end if;</span>
        <span class="kw">end process</span>;
    saida_clk <span class="ot">&lt;=</span> tick;
    <span class="er">end architecture divInteiro;</span></code></pre></div>
<hr />
<p><a name="topLevel"></a></p>
<h4 id="exemplo-de-uso-do-divisor">Exemplo de uso do divisor</h4>
<p><strong>Nome do arquivo: top_level.vhd</strong></p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span class="kw">LIBRARY</span> ieee;
<span class="kw">USE</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>ALL;
<span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">top_level</span> <span class="kw">is</span>
   <span class="kw">port</span>(
      clk        <span class="ot">:</span>   <span class="kw">in</span> <span class="dt">std_logic</span>;
      saida_clk <span class="ot">:</span>   <span class="kw">out</span> <span class="dt">std_logic</span>
   );
<span class="er">end entity;</span>

<span class="kw">architecture</span> <span class="kw">teste</span> <span class="kw">of</span> <span class="kw">top_level</span> <span class="kw">is</span>

<span class="kw">begin</span>
<span class="kw">fazDivisaoPot2</span><span class="ot">:</span> <span class="er">entity</span> <span class="er">work</span><span class="ot">.</span><span class="er">divisorGenerico(divPotenciaDe2)</span>
            <span class="kw">generic map (</span>divisor <span class="ot">=&gt;</span> <span class="dv">5</span>)   <span class="co">-- divide por 2^6.</span>
            <span class="kw">port map (</span>clk <span class="ot">=&gt;</span> clk<span class="ot">,</span> saida_clk <span class="ot">=&gt;</span> saida_clk);

<span class="kw">fazDivisaoInteiro</span><span class="ot">:</span> <span class="er">entity</span> <span class="er">work</span><span class="ot">.</span><span class="er">divisorGenerico(divInteiro)</span>
            <span class="kw">generic map (</span>divisor <span class="ot">=&gt;</span> <span class="dv">5</span>)   <span class="co">-- divide por 10.</span>
            <span class="kw">port map (</span>clk <span class="ot">=&gt;</span> clk<span class="ot">,</span> saida_clk <span class="ot">=&gt;</span> saida_clk);

<span class="kw">end architecture;</span></code></pre></div>
<hr />
<h3 id="registrador-de-deslocamento-genérico">Registrador de Deslocamento Genérico</h3>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">library</span> ieee;
<span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;
<span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">registradorDeslocamento</span> <span class="kw">is</span>
    <span class="kw">generic</span> ( estagios <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span> );
    <span class="kw">port</span> (
        clk     <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
        enable  <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
        rst    <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
        sr_out  <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>((estagios<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>)
    );
<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">rtl</span> <span class="kw">of</span> <span class="kw">registradorDeslocamento</span> <span class="kw">is</span>
    <span class="ot">signal</span> sr <span class="ot">:</span> <span class="dt">std_logic_vector</span> ((estagios<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
<span class="kw">begin</span>
    <span class="kw">process</span> (clk<span class="ot">,</span> rst)
    <span class="ot">variable</span> ZERO <span class="ot">:</span> <span class="dt">std_logic_vector</span> ((estagios<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
    <span class="kw">begin</span>
        ZERO <span class="ot">:=</span> (<span class="ot">others</span> <span class="ot">=&gt;</span> <span class="bn">&#39;0&#39;</span>);
        <span class="kw">if</span> (rst <span class="ot">=</span> <span class="bn">&#39;1&#39;</span>) <span class="kw">then</span>
                sr <span class="ot">&lt;=</span> (<span class="ot">others</span> <span class="ot">=&gt;</span> <span class="bn">&#39;0&#39;</span>);
        <span class="kw">elsif</span> (<span class="kw">rising_edge</span>(clk)) <span class="kw">then</span>
            <span class="kw">if</span> (enable <span class="ot">=</span> <span class="bn">&#39;1&#39;</span>) <span class="kw">then</span>
                <span class="kw">if</span> (sr <span class="ot">=</span> ZERO) <span class="kw">then</span>
                    sr(<span class="dv">0</span>) <span class="ot">&lt;=</span> <span class="bn">&#39;1&#39;</span>;
                <span class="kw">else</span>
                    sr <span class="ot">&lt;=</span> <span class="dt">std_logic_vector</span>(<span class="dt">unsigned</span>(sr) <span class="kw">rol</span> <span class="dv">1</span>);
                <span class="kw">end if;</span>
            <span class="kw">end if;</span>
        <span class="kw">end if;</span>
    <span class="kw">end process</span>;
    sr_out <span class="ot">&lt;=</span> sr;
<span class="kw">end architecture;</span></code></pre></div>
<hr />
<h2 id="memórias">Memórias</h2>
<p>As memórias podem ser:</p>
<ul>
<li><p>Somente Leitura (ROM);</p></li>
<li><p>Leitura e Escrita (RAM);</p></li>
<li><p>Síncronas:</p>
<ul>
<li><p>Só alteram o conteúdo armazenado na transição do <em>clock</em>;</p></li>
<li><p>Só alteram o conteúdo sendo lido (exibido) a partir da transição do <em>clock</em>.</p></li>
</ul></li>
<li><p>Assíncronas:</p>
<ul>
<li><p>A partir do aparecimento de um novo endereço, elas exibem o conteúdo da posição de memória após o tempo de propagação.</p></li>
<li><p>A alteração do conteúdo é controlada pelo sinal de escrita (WR).</p></li>
</ul></li>
</ul>
<p>Uma característica do VHDL é o endereçamento de memória ser feito com um tipo inteiro.</p>
<p>Porém, para a simulação se beneficiar dos recursos multinível do tipo <em>std_logic(_vector)</em> precisamos que a interface dos componentes usem esse tipo de dados.</p>
<p>No caso das memórias, deve-se converter o valor do endereço de <em>std_logic_vector</em> para inteiro, conforme mostrado abaixo:</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">memoria(to_integer(unsigned(endereco))) <span class="ot">&lt;=</span> dado;

dado <span class="ot">&lt;=</span> memoria(to_integer(unsigned(endereco)));</code></pre></div>
<h3 id="banco-de-registradores-mips">Banco de Registradores MIPS</h3>
<p>Possuem a escrita síncrona e a leitura assíncrona.</p>
<p>Ver mais detalhes na descrição do processador.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span class="kw">library</span> ieee;
<span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;
<span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;

<span class="co">-- Baseado no apendice C (Register Files) do COD (Patterson &amp; Hennessy).</span>

<span class="kw">entity</span> <span class="kw">bancoRegistradores</span> <span class="kw">is</span>
    <span class="kw">generic</span>
    (
        larguraDados        <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">32</span>;
        larguraEndBancoRegs <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">5</span>   <span class="co">--Resulta em 2^5=32 posicoes</span>
    );
<span class="co">-- Leitura de 2 registradores e escrita em 1 registrador simultaneamente.</span>
    <span class="kw">port</span>
    (
        clk        <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
<span class="co">--</span>
        enderecoA       <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>((larguraEndBancoRegs<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
        enderecoB       <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>((larguraEndBancoRegs<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
        enderecoC       <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>((larguraEndBancoRegs<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
<span class="co">--</span>
        dadoEscritaC    <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>((larguraDados<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
<span class="co">--</span>
        escreveC        <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span> <span class="ot">:=</span> <span class="bn">&#39;0&#39;</span>;
        saidaA          <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>((larguraDados <span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
        saidaB          <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>((larguraDados <span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>)
    );
<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">comportamento</span> <span class="kw">of</span> <span class="kw">bancoRegistradores</span> <span class="kw">is</span>

    <span class="kw">subtype</span> palavra_t <span class="kw">is</span> <span class="dt">std_logic_vector</span>((larguraDados<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
    <span class="ot">type</span> memoria_t <span class="kw">is</span> <span class="kw">array</span>(<span class="dv">2</span><span class="ot">**</span>larguraEndBancoRegs<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>) <span class="kw">of</span> palavra_t;

    <span class="co">-- Declaracao dos registradores:</span>
    <span class="kw">shared</span> <span class="ot">variable</span> registrador <span class="ot">:</span> memoria_t;

<span class="kw">begin</span>
    <span class="kw">process</span>(clk) <span class="kw">is</span>
    <span class="kw">begin</span>
        <span class="kw">if</span> (<span class="kw">rising_edge</span>(clk)) <span class="kw">then</span>
            <span class="kw">if</span> (escreveC <span class="ot">=</span> <span class="bn">&#39;1&#39;</span>) <span class="kw">then</span>
                registrador(to_integer(<span class="dt">unsigned</span>(enderecoC))) <span class="ot">:=</span> dadoEscritaC;
            <span class="kw">end if;</span>
        <span class="kw">end if;</span>
    <span class="kw">end process</span>;

    <span class="co">-- IF endereco = 0 : retorna ZERO</span>
     <span class="kw">process</span>(<span class="kw">all</span>) <span class="kw">is</span>
     <span class="kw">begin</span>
         <span class="kw">if</span> (<span class="dt">unsigned</span>(enderecoA) <span class="ot">=</span> <span class="dv">0</span>) <span class="kw">then</span>
            saidaA <span class="ot">&lt;=</span> (<span class="ot">others</span> <span class="ot">=&gt;</span> <span class="bn">&#39;0&#39;</span>);
         <span class="kw">else</span>
            saidaA <span class="ot">&lt;=</span> registrador(to_integer(<span class="dt">unsigned</span>(enderecoA)));
         <span class="kw">end if;</span>
         <span class="kw">if</span> (<span class="dt">unsigned</span>(enderecoB) <span class="ot">=</span> <span class="dv">0</span>) <span class="kw">then</span>
            saidaB <span class="ot">&lt;=</span> (<span class="ot">others</span> <span class="ot">=&gt;</span> <span class="bn">&#39;0&#39;</span>);
         <span class="kw">else</span>
            saidaB <span class="ot">&lt;=</span> registrador(to_integer(<span class="dt">unsigned</span>(enderecoB)));
        <span class="kw">end if;</span>
     <span class="kw">end process</span>;
<span class="kw">end architecture;</span></code></pre></div>
<hr />
<h3 id="rom">ROM</h3>
<p>O seu conteúdo deve ter sido previamente gravado no dispositivo.</p>
<p>Possuem a leitura assíncrona.</p>
<h3 id="rom-assíncrona-com-a-inicialização-em-vhdl">ROM Assíncrona com a Inicialização em VHDL</h3>
<p>A função initMemory carrega os dados na ROM da FPGA.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">library</span> IEEE;
<span class="kw">use</span> IEEE<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;
<span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">memoria</span> <span class="kw">is</span>
   <span class="kw">generic</span> (
          dataWidth<span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>;
          addrWidth<span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">3</span>
    );
   <span class="kw">port</span> (
          Endereco <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span> (addrWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">DOWNTO</span> <span class="dv">0</span>);
          Dado <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span> (dataWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">DOWNTO</span> <span class="dv">0</span>)
    );
<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">assincrona</span> <span class="kw">of</span> <span class="kw">memoria</span> <span class="kw">is</span>

  <span class="ot">type</span> blocoMemoria <span class="kw">is</span> <span class="kw">array</span>(<span class="dv">0</span> <span class="ot">TO</span> <span class="dv">2</span><span class="ot">**</span>addrWidth <span class="ot">-</span> <span class="dv">1</span>) <span class="kw">of</span> <span class="dt">std_logic_vector</span>(dataWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">DOWNTO</span> <span class="dv">0</span>);

  <span class="kw">function</span> initMemory
        <span class="kw">return</span> blocoMemoria <span class="kw">is</span> <span class="ot">variable</span> tmp <span class="ot">:</span> blocoMemoria <span class="ot">:=</span> (<span class="ot">others</span> <span class="ot">=&gt;</span> (<span class="ot">others</span> <span class="ot">=&gt;</span> <span class="bn">&#39;0&#39;</span>));
  <span class="kw">begin</span>
        <span class="co">-- Inicializa os endereços:</span>
        tmp(<span class="dv">0</span>) <span class="ot">:=</span> x<span class="st">&quot;AA&quot;</span>;
        tmp(<span class="dv">1</span>) <span class="ot">:=</span> x<span class="st">&quot;42&quot;</span>;
        tmp(<span class="dv">2</span>) <span class="ot">:=</span> x<span class="st">&quot;43&quot;</span>;
        tmp(<span class="dv">3</span>) <span class="ot">:=</span> x<span class="st">&quot;44&quot;</span>;
        tmp(<span class="dv">4</span>) <span class="ot">:=</span> x<span class="st">&quot;45&quot;</span>;
        tmp(<span class="dv">5</span>) <span class="ot">:=</span> x<span class="st">&quot;46&quot;</span>;
        tmp(<span class="dv">6</span>) <span class="ot">:=</span> x<span class="st">&quot;47&quot;</span>;
        tmp(<span class="dv">7</span>) <span class="ot">:=</span> x<span class="st">&quot;55&quot;</span>;
        <span class="kw">return</span> tmp;
    <span class="kw">end </span>initMemory;

    <span class="ot">signal</span> memROM <span class="ot">:</span> blocoMemoria <span class="ot">:=</span> initMemory;

<span class="kw">begin</span>
    Dado <span class="ot">&lt;=</span> memROM (to_integer(<span class="dt">unsigned</span>(Endereco)));
<span class="kw">end architecture;</span></code></pre></div>
<h3 id="rom-assíncrona-com-a-inicialização-a-partir-de-um-arquivo-.mif">ROM Assíncrona com a Inicialização a partir de um Arquivo <em>&quot;.mif&quot;</em>:</h3>
<p>A definição do tipo de dados da memória lê um arquivo definido com os dados e os carrega na ROM da FPGA.</p>
<div class="sourceCode"><pre class="sourceCode vhd"><code class="sourceCode vhdl">
<span class="kw">library</span> ieee;
<span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;
<span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">romMif</span> <span class="kw">is</span>

    <span class="kw">generic</span>
    (
        dataWidth <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>;
        addrWidth <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>
    );

    <span class="kw">port</span> (
          Endereco <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span> (addrWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">DOWNTO</span> <span class="dv">0</span>);
          Dado <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span> (dataWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">DOWNTO</span> <span class="dv">0</span>)
    );
<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">initFileROM</span> <span class="kw">of</span> <span class="kw">romMif</span> <span class="kw">is</span>

<span class="ot">type</span> memory_t <span class="kw">is</span> <span class="kw">array</span> (<span class="dv">2</span><span class="ot">**</span>addrWidth <span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>) <span class="kw">of</span> <span class="dt">std_logic_vector</span> (dataWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
<span class="ot">signal</span> content<span class="ot">:</span> memory_t;
<span class="ot">attribute</span> ram_init_file <span class="ot">:</span> <span class="dt">string</span>;
<span class="ot">attribute</span> ram_init_file <span class="kw">of</span> content<span class="ot">:</span>
<span class="ot">signal</span> <span class="kw">is</span> <span class="st">&quot;initROM.mif&quot;</span>;

<span class="kw">begin</span>
   Dado <span class="ot">&lt;=</span> content(to_integer(<span class="dt">unsigned</span>(Endereco)));
<span class="er">end architecture;</span></code></pre></div>
<h4 id="formato-do-arquivo-initrom.mif">Formato do arquivo initROM.mif:</h4>
<div class="sourceCode"><pre class="sourceCode vhd"><code class="sourceCode vhdl">
<span class="co">-- Copyright (C) 2017  Intel Corporation. All rights reserved.</span>
<span class="co">-- Your use of Intel Corporation&#39;s design tools, logic functions</span>
<span class="co">-- and other software and tools, and its AMPP partner logic</span>
<span class="co">-- functions, and any output files from any of the foregoing</span>
<span class="co">-- (including device programming or simulation files), and any</span>
<span class="co">-- associated documentation or information are expressly subject</span>
<span class="co">-- to the terms and conditions of the Intel Program License</span>
<span class="co">-- Subscription Agreement, the Intel Quartus Prime License Agreement,</span>
<span class="co">-- the Intel FPGA IP License Agreement, or other applicable license</span>
<span class="co">-- agreement, including, without limitation, that your use is for</span>
<span class="co">-- the sole purpose of programming logic devices manufactured by</span>
<span class="co">-- Intel and sold by Intel or its authorized distributors.  Please</span>
<span class="co">-- refer to the applicable agreement for further details.</span>

WIDTH<span class="ot">=</span>8;
DEPTH<span class="ot">=</span>256;
ADDRESS_RADIX<span class="ot">=</span>DEC;
DATA_RADIX<span class="ot">=</span>HEX;

CONTENT BEGIN
<span class="co">--endereco : dado;</span>
    0    <span class="ot">:</span>   44;
    1    <span class="ot">:</span>   41;
    2    <span class="ot">:</span>   4C;
    3    <span class="ot">:</span>   2F;
    <span class="ot">[</span>4<span class="ot">..</span>5<span class="ot">]</span> <span class="ot">:</span> 20;
    6    <span class="ot">:</span>   22;
    <span class="ot">[</span>7<span class="ot">..</span>8<span class="ot">]</span> <span class="ot">:</span> 00;
    9    <span class="ot">:</span>   01;
    10   <span class="ot">:</span>   6A;
    11   <span class="ot">:</span>   AB;
    12   <span class="ot">:</span>   1B;
    13   <span class="ot">:</span>   AC;
    14   <span class="ot">:</span>   09;
    15   <span class="ot">:</span>   00;
    16   <span class="ot">:</span>   AF;
    17   <span class="ot">:</span>   00;
    18   <span class="ot">:</span>   AE;
    19   <span class="ot">:</span>   11;
    20   <span class="ot">:</span>   01;
    <span class="ot">[</span>21<span class="ot">..</span>23<span class="ot">]</span> <span class="ot">:</span> 00;
    24   <span class="ot">:</span>   AE;
    25   <span class="ot">:</span>   14;
    <span class="ot">[</span>26<span class="ot">..</span>28<span class="ot">]</span> <span class="ot">:</span> 00;
    29   <span class="ot">:</span>   8D;
    30   <span class="ot">:</span>   0C;
    <span class="ot">[</span>31<span class="ot">..</span>33<span class="ot">]</span> <span class="ot">:</span> 00;
    34   <span class="ot">:</span>   AE;
    <span class="ot">[</span>35<span class="ot">..</span>37<span class="ot">]</span> <span class="ot">:</span> 00;
    38   <span class="ot">:</span>   26;
    <span class="ot">[</span>39<span class="ot">..</span>255<span class="ot">]</span> <span class="ot">:</span> 20;
END;</code></pre></div>
<hr />
<h3 id="single-port-ram-com-leitura-assíncrona">Single Port RAM com Leitura Assíncrona</h3>
<p>A escrita é síncrona e a leitura assíncrona. Ou seja, se o endereço para a leitura mudar durante qualquer parte do período de <em>clock</em>, a saída mudará após o tempo de propagação - independendo da borda do <em>clock</em>.</p>
<p>Modelo retirado dos <em>templates</em> do Quartus e modificado para ter o endereço do tipo <em>std_logic_vector</em> e leitura assíncrona.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">library</span> ieee;
<span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;
<span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">single_port_ram</span> <span class="kw">is</span>
   <span class="kw">generic</span> (
         dataWidth<span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>;
         addrWidth<span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>
    );
    <span class="kw">port</span>
    (
        addr     <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>(addrWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
        we       <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span> <span class="ot">:=</span> <span class="bn">&#39;1&#39;</span>;
        clk      <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
        dado_in  <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>(dataWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
        dado_out <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>(dataWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>)
    );
<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">rtl</span> <span class="kw">of</span> <span class="kw">single_port_ram</span> <span class="kw">is</span>
    <span class="co">-- Build a 2-D array type for the RAM</span>
    <span class="kw">subtype</span> word_t <span class="kw">is</span> <span class="dt">std_logic_vector</span>(dataWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
    <span class="ot">type</span> memory_t <span class="kw">is</span> <span class="kw">array</span>((<span class="dv">2</span><span class="ot">**</span>addrWidth<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>) <span class="kw">of</span> word_t;

    <span class="co">-- Declare the RAM signal.</span>
    <span class="ot">signal</span> ram <span class="ot">:</span> memory_t;
<span class="kw">begin</span>
    <span class="kw">process</span>(clk)
    <span class="kw">begin</span>
        <span class="kw">if</span>(<span class="kw">rising_edge</span>(clk)) <span class="kw">then</span>
            <span class="kw">if</span>(we <span class="ot">=</span> <span class="bn">&#39;1&#39;</span>) <span class="kw">then</span>
                ram(to_integer(<span class="dt">unsigned</span>(addr))) <span class="ot">&lt;=</span> dado_in;
            <span class="kw">end if;</span>
        <span class="kw">end if;</span>
    <span class="kw">end process</span>;
    dado_out <span class="ot">&lt;=</span> ram(to_integer(<span class="dt">unsigned</span>(addr)));
<span class="kw">end architecture;</span></code></pre></div>
<hr />
<h3 id="single-port-ram-com-leitura-e-escrita-síncronos">Single Port RAM com Leitura e Escrita Síncronos</h3>
<p>A escrita e leitura são síncronas.</p>
<p>Modelo retirado dos <em>templates</em> do Quartus e modificado para ter o endereço do tipo <em>std_logic_vector</em>.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">library</span> ieee;
<span class="kw">use</span> ieee<span class="ot">.</span>std_logic_1164<span class="ot">.</span>all;
<span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;

<span class="kw">entity</span> <span class="kw">single_port_ram</span> <span class="kw">is</span>
   <span class="kw">generic</span> (
         dataWidth<span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>;
         addrWidth<span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>
    );
    <span class="kw">port</span>
    (
        addr     <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>(addrWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
        we       <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span> <span class="ot">:=</span> <span class="bn">&#39;1&#39;</span>;
        clk      <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
        dado_in  <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>(dataWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
        dado_out <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>(dataWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>)
    );
<span class="kw">end entity;</span>

<span class="kw">architecture</span> <span class="kw">rtl</span> <span class="kw">of</span> <span class="kw">single_port_ram</span> <span class="kw">is</span>
    <span class="co">-- Build a 2-D array type for the RAM</span>
    <span class="kw">subtype</span> word_t <span class="kw">is</span> <span class="dt">std_logic_vector</span>(dataWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
    <span class="ot">type</span> memory_t <span class="kw">is</span> <span class="kw">array</span>((<span class="dv">2</span><span class="ot">**</span>addrWidth<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>) <span class="kw">of</span> word_t;

    <span class="co">-- Declare the RAM signal.</span>
    <span class="ot">signal</span> ram <span class="ot">:</span> memory_t;

    <span class="co">-- Register to hold the address during one clock cycle.</span>
    <span class="ot">signal</span> addr_reg <span class="ot">:</span> <span class="dt">std_logic_vector</span>(addrWidth<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);

<span class="kw">begin</span>
    <span class="kw">process</span>(clk)
    <span class="kw">begin</span>
        <span class="kw">if</span>(<span class="kw">rising_edge</span>(clk)) <span class="kw">then</span>
            <span class="kw">if</span>(we <span class="ot">=</span> <span class="bn">&#39;1&#39;</span>) <span class="kw">then</span>
                ram(to_integer(<span class="dt">unsigned</span>(addr))) <span class="ot">&lt;=</span> dado_in;
            <span class="kw">end if;</span>
            <span class="co">-- Register the address for reading during one clock cycle.</span>
            addr_reg <span class="ot">&lt;=</span> addr;
        <span class="kw">end if;</span>
    <span class="kw">end process</span>;
    dado_out <span class="ot">&lt;=</span> ram(to_integer(<span class="dt">unsigned</span>(addr_reg)));
<span class="kw">end architecture;</span></code></pre></div>
<hr />
<hr />
<h2 id="biblioteca">Biblioteca</h2>
<h3 id="biblioteca-de-componentes">Biblioteca de Componentes</h3>
<p>Este arquivo é <i>somente um exemplo</i>, antes de usar faça os ajustes necessários para a sua implementação.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">library</span> IEEE;
<span class="kw">use</span> IEEE<span class="ot">.</span>STD_LOGIC_1164<span class="ot">.</span>all;
<span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;

<span class="kw">package</span> bibliotecaComponentes <span class="kw">is</span>


    <span class="kw">component</span> conversorHex7Seg <span class="kw">is</span>
        <span class="kw">port</span>
        (
            <span class="co">-- Input ports</span>
            dadoHex <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic_vector</span>(<span class="dv">3</span> <span class="ot">downto</span> <span class="dv">0</span>);
            apaga   <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic</span>;
            negativo <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic</span>;
            overFlow <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic</span>;
            <span class="co">-- Output ports</span>
            saida7seg <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>(<span class="dv">6</span> <span class="ot">downto</span> <span class="dv">0</span>)
        );
    <span class="kw">end</span> <span class="kw">component</span> conversorHex7Seg;

<span class="co">-----------------------------------------------------------------------------------</span>

    <span class="kw">component</span> bancoRegistradores <span class="kw">is</span>
        <span class="kw">generic</span>
        (
            larguraDados        <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>;
            larguraEndBancoRegs <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">5</span>
        );
    <span class="co">-- Leitura de 2 registradores e escrita em 1 registrador simultaneamente.</span>
        <span class="kw">port</span>
        (
            clk        <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
    <span class="co">--</span>
            enderecoA       <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>((larguraEndBancoRegs<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
            enderecoB       <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>((larguraEndBancoRegs<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
            enderecoC       <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>((larguraEndBancoRegs<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
    <span class="co">--</span>
            dadoEscritaC    <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>((larguraDados<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
    <span class="co">--</span>
            escreveC          <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
            saidaA          <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>((larguraDados <span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
            saidaB          <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>((larguraDados <span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>)
        );
    <span class="kw">end</span> <span class="kw">component</span> bancoRegistradores;

<span class="co">-----------------------------------------------------------------------------------</span>

    <span class="kw">component</span> divisorGenerico <span class="kw">is</span>
        <span class="kw">generic</span>
        (divisor <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>);
        <span class="kw">port</span>(
            clk         <span class="ot">:</span>   <span class="kw">in</span> <span class="dt">std_logic</span>;
            saida_clk <span class="ot">:</span>   <span class="kw">out</span> <span class="dt">std_logic</span>
            );
    <span class="kw">end</span> <span class="kw">component</span> divisorGenerico;

<span class="co">-----------------------------------------------------------------------------------</span>

    <span class="kw">component</span> edgeDetector <span class="kw">is</span>
         <span class="kw">Port</span> ( clk     <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic</span>;
                  entrada <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic</span>;
                  saida   <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic</span>);
    <span class="kw">end</span> <span class="kw">component</span> edgeDetector;

<span class="co">-----------------------------------------------------------------------------------</span>

    <span class="kw">component</span> estendeSinalGenerico <span class="kw">is</span>
        <span class="kw">generic</span>
        (
            larguraDadoEntrada <span class="ot">:</span> <span class="dt">natural</span>  <span class="ot">:=</span>    <span class="dv">8</span>;
            larguraDadoSaida   <span class="ot">:</span> <span class="dt">natural</span>  <span class="ot">:=</span>    <span class="dv">8</span>
        );
        <span class="kw">port</span>
        (
            <span class="co">-- Input ports</span>
            estendeSinal_IN <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic_vector</span>(larguraDadoEntrada<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
            <span class="co">-- Output ports</span>
            estendeSinal_OUT<span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>(larguraDadoSaida<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>)
        );
    <span class="kw">end</span> <span class="kw">component</span> estendeSinalGenerico;

<span class="co">-----------------------------------------------------------------------------------</span>

    <span class="kw">component</span> muxGenerico2 <span class="kw">is</span>
        <span class="kw">generic</span> (
            <span class="co">-- Total de bits das entradas e saidas</span>
            larguraDados    <span class="ot">:</span> <span class="dt">natural</span>  <span class="ot">:=</span>   <span class="dv">8</span>
        );
        <span class="kw">port</span> (
    <span class="co">--      -- Input ports</span>
            entradaA_MUX    <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic_vector</span>(larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
            entradaB_MUX    <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic_vector</span>(larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
            seletorMUX  <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic</span>;
    <span class="co">--</span>
    <span class="co">--      -- Output ports</span>
            saidaMUX   <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>(larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>)
        );
    <span class="kw">end</span> <span class="kw">component</span> muxGenerico2;

<span class="co">-----------------------------------------------------------------------------------</span>

    <span class="kw">component</span> registradorGenerico <span class="kw">is</span>
    <span class="kw">generic</span> (
        larguraDados <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">8</span>
    );
    <span class="kw">port</span> (DIN <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic_vector</span>(larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
           DOUT <span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>(larguraDados<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
           ENABLE <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>;
           CLK<span class="ot">,</span>RST <span class="ot">:</span> <span class="kw">in</span> <span class="dt">std_logic</span>);
    <span class="kw">end</span> <span class="kw">component</span> registradorGenerico;

<span class="co">-----------------------------------------------------------------------------------</span>

    <span class="kw">component</span> somaConstanteGenerico <span class="kw">is</span>
         <span class="kw">generic</span> (
              larguraDados <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">32</span>;
              incremento <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">4</span>
         );
         <span class="kw">port</span> (
              entrada<span class="ot">:</span> <span class="kw">in</span>  <span class="dt">STD_LOGIC_VECTOR</span>((larguraDados<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
              saida<span class="ot">:</span>   <span class="kw">out</span> <span class="dt">STD_LOGIC_VECTOR</span>((larguraDados<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>)
         );
         <span class="kw">end</span> <span class="kw">component</span> somaConstanteGenerico;

<span class="co">-----------------------------------------------------------------------------------</span>

     <span class="kw">component</span> somadorGenerico <span class="kw">is</span>
            <span class="kw">generic</span> ( larguraDados <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">32</span> );
        <span class="kw">port</span> (
            entradaA<span class="ot">,</span> entradaB<span class="ot">:</span> <span class="kw">in</span> <span class="dt">STD_LOGIC_VECTOR</span>((larguraDados<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>);
            saida<span class="ot">:</span>  <span class="kw">out</span> <span class="dt">STD_LOGIC_VECTOR</span>((larguraDados<span class="ot">-</span><span class="dv">1</span>) <span class="ot">downto</span> <span class="dv">0</span>) );
     <span class="kw">end</span> <span class="kw">component</span> somadorGenerico;

<span class="co">-----------------------------------------------------------------------------------</span>

    <span class="kw">component</span> deslocadorGenerico <span class="kw">is</span>
    <span class="kw">generic</span> (
        larguraDadoEntrada <span class="ot">:</span> <span class="dt">natural</span>  <span class="ot">:=</span>    <span class="dv">8</span>;
        larguraDadoSaida   <span class="ot">:</span> <span class="dt">natural</span>  <span class="ot">:=</span>    <span class="dv">8</span>;
        deslocamento <span class="ot">:</span> <span class="dt">natural</span> <span class="ot">:=</span> <span class="dv">2</span>  );
    <span class="kw">port</span> (
        <span class="co">-- Input ports</span>
        sinalIN <span class="ot">:</span> <span class="kw">in</span>  <span class="dt">std_logic_vector</span>(larguraDadoEntrada<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>);
        <span class="co">-- Output ports</span>
        sinalOUT<span class="ot">:</span> <span class="kw">out</span> <span class="dt">std_logic_vector</span>(larguraDadoSaida<span class="ot">-</span><span class="dv">1</span> <span class="ot">downto</span> <span class="dv">0</span>) );
     <span class="kw">end</span> <span class="kw">component</span> deslocadorGenerico;

<span class="kw">end</span> <span class="kw">package</span> bibliotecaComponentes;</code></pre></div>
<hr />
<h3 id="biblioteca-de-constantes">Biblioteca de Constantes</h3>
<p>Este arquivo é <i>somente um exemplo</i>, antes de usar faça os ajustes necessários para a sua implementação.</p>
<div class="sourceCode"><pre class="sourceCode vhdl"><code class="sourceCode vhdl">
<span class="kw">library</span> IEEE;
<span class="kw">use</span> IEEE<span class="ot">.</span>STD_LOGIC_1164<span class="ot">.</span>all;
<span class="kw">use</span> ieee<span class="ot">.</span>numeric_std<span class="ot">.</span>all;

package constantesMIPS is

<span class="co">--  Exemplos:</span>
<span class="co">--  signal Instruction : Bit_Vector(15 downto 0);</span>
<span class="co">--  alias OpCode : Bit_Vector(3 downto 0) is Instruction(15 downto 12);</span>
<span class="co">--  subtype TypeWord is unsigned( 31 downto 0 );</span>
<span class="co">--  type    TypeArrayWord is array (natural range &lt;&gt;) of unsigned( 31 downto 0 );</span>
<span class="co">--  constant FUNCT_WIDTH : natural := 6;</span>

    constant FUNCT_WIDTH    <span class="ot">:</span> natural <span class="ot">:=</span> 6;
    constant OPCODE_WIDTH   <span class="ot">:</span> natural <span class="ot">:=</span> 6;
    constant DATA_WIDTH     <span class="ot">:</span> natural <span class="ot">:=</span> 32;
    constant ADDR_WIDTH     <span class="ot">:</span> natural <span class="ot">:=</span> 32;
    constant REGBANK_ADDR_WIDTH <span class="ot">:</span> natural <span class="ot">:=</span> 5;
    constant ALU_OP_WIDTH   <span class="ot">:</span> natural <span class="ot">:=</span> 2;
    constant CTRL_ALU_WIDTH <span class="ot">:</span> natural <span class="ot">:=</span> 3;
    constant CONTROLWORD_WIDTH <span class="ot">:</span> natural <span class="ot">:=</span> 10;

<span class="co">-- codigos das instrucoes do DLX:</span>
    subtype opCode_t       is std_logic_vector(OPCODE_WIDTH<span class="ot">-</span>1 downto 0);
    subtype funct_t        is std_logic_vector(FUNCT_WIDTH<span class="ot">-</span>1 downto 0);
    subtype ctrlWorld_t    is std_logic_vector(CONTROLWORD_WIDTH<span class="ot">-</span>1 downto 0);
    subtype aluOp_t        is std_logic_vector(ALU_OP_WIDTH<span class="ot">-</span>1 downto 0);
    subtype ctrlALU_t      is std_logic_vector(CTRL_ALU_WIDTH<span class="ot">-</span>1 downto 0);

    subtype dado_t         is std_logic_vector(DATA_WIDTH<span class="ot">-</span>1 downto 0);
    subtype addr_t         is std_logic_vector(ADDR_WIDTH<span class="ot">-</span>1 downto 0);
<span class="co">--</span>
    constant functADD   <span class="ot">:</span> funct_t <span class="ot">:=</span> <span class="st">&quot;100000&quot;</span>;
    constant functSUB   <span class="ot">:</span> funct_t <span class="ot">:=</span> <span class="st">&quot;100010&quot;</span>;
    constant functAND   <span class="ot">:</span> funct_t <span class="ot">:=</span> <span class="st">&quot;100100&quot;</span>;
    constant functOR    <span class="ot">:</span> funct_t <span class="ot">:=</span> <span class="st">&quot;100101&quot;</span>;
    constant functSLT   <span class="ot">:</span> funct_t <span class="ot">:=</span> <span class="st">&quot;101010&quot;</span>;

    constant opCodeTipoR  <span class="ot">:</span> opCode_t <span class="ot">:=</span> <span class="st">&quot;000000&quot;</span>;
<span class="co">--</span>
    constant opCodeLW     <span class="ot">:</span> opCode_t <span class="ot">:=</span> <span class="st">&quot;100011&quot;</span>;
    constant opCodeSW     <span class="ot">:</span> opCode_t <span class="ot">:=</span> <span class="st">&quot;101011&quot;</span>;
    constant opCodeBEQ    <span class="ot">:</span> opCode_t <span class="ot">:=</span> <span class="st">&quot;000100&quot;</span>;
<span class="co">--</span>
    constant opCodeTipoJ  <span class="ot">:</span> opCode_t <span class="ot">:=</span> <span class="st">&quot;000010&quot;</span>;

<span class="co">--</span>
<span class="co">-- Codigos da palavra de controle:</span>
<span class="co">--  alias memWRsignal: std_logic is controlWord(0);</span>
<span class="co">--  alias memRDsignal: std_logic is controlWord(1);</span>
<span class="co">--  alias beqSignal:   std_logic is controlWord(2);</span>
<span class="co">--  alias muxUlaMem:   std_logic is controlWord(3);</span>
<span class="co">--  alias ulaOPvalue:  std_logic_vector(1 downto 0) is controlWord(5 downto 4);</span>
<span class="co">--  alias muxRtImed:   std_logic is controlWord(6);</span>
<span class="co">--  alias regcWRsignal:std_logic is controlWord(7);</span>
<span class="co">--  alias muxRtRd:     std_logic is controlWord(8);</span>
<span class="co">--  alias muxPcBeqJ:   std_logic is controlWord(9);</span>
<span class="co">--</span>
<span class="co">-- ControlWorld Bit:    9   8       7           6     5,4    3     2      1       0</span>
<span class="co">--Instrução  Opcode    Mux1 Mux2 HabEscritaReg Mux3  ULAOp  Mux4  BEQ HabLeMEM HabEscME</span>
<span class="co">--Tipo R    |00.0000  | 0 |  1 |     1        |  0  |  10  |  0  | 0 |    0   |    0    |</span>
<span class="co">--LW        |10.0011  | 0 |  0 |     1        |  1  |  00  |  1  | 0 |    1   |    0    |</span>
<span class="co">--SW        |10.1011  | 0 |  0 |     0        |  1  |  00  |  0  | 0 |    0   |    1    |</span>
<span class="co">--BEQ       |00.0100  | 0 |  0 |     0        |  0  |  01  |  0  | 1 |    0   |    0    |</span>
<span class="co">--J         |00.0010  | 1 |  X |     0        |  X  |  XX  |  X  | X |    0   |    0    |</span>

<span class="co">--  Mux1: mux([PC+4, BEQ]/J);  Mux2: mux(Rt/Rd); Mux3: mux(Rt/imediato);  Mux4: mux(ULA/mem).</span>

    constant ctrlTipoR<span class="ot">:</span>       ctrlWorld_t <span class="ot">:=</span> <span class="st">&quot;0110100000&quot;</span>;
    constant ctrlTipoJ<span class="ot">:</span>       ctrlWorld_t <span class="ot">:=</span> <span class="st">&quot;1X0XXXXX00&quot;</span>;
    constant ctrlTipoLW<span class="ot">:</span>      ctrlWorld_t <span class="ot">:=</span> <span class="st">&quot;0011001010&quot;</span>;
    constant ctrlTipoSW<span class="ot">:</span>      ctrlWorld_t <span class="ot">:=</span> <span class="st">&quot;0001000001&quot;</span>;
    constant ctrlTipoBEQ<span class="ot">:</span>     ctrlWorld_t <span class="ot">:=</span> <span class="st">&quot;0000010100&quot;</span>;
    constant ctrlZERO<span class="ot">:</span>        ctrlWorld_t <span class="ot">:=</span> <span class="st">&quot;0000000000&quot;</span>;

<span class="co">--  -- ULA ---</span>
    subtype operacaoULA_t is std_logic_vector(2 downto 0);

    constant execAndULA <span class="ot">:</span> operacaoULA_t <span class="ot">:=</span> <span class="st">&quot;000&quot;</span>;
    constant execOrULA  <span class="ot">:</span> operacaoULA_t <span class="ot">:=</span> <span class="st">&quot;001&quot;</span>;
    constant execAddULA <span class="ot">:</span> operacaoULA_t <span class="ot">:=</span> <span class="st">&quot;010&quot;</span>;
    constant execSubULA <span class="ot">:</span> operacaoULA_t <span class="ot">:=</span> <span class="st">&quot;110&quot;</span>;
    constant execSltULA <span class="ot">:</span> operacaoULA_t <span class="ot">:=</span> <span class="st">&quot;111&quot;</span>;
end package constantesMIPS;</code></pre></div>
<hr />
<p><br></p>
<hr />
<hr />
<!-- FIM -->
<!---

## Inicialização de ROM com interface usando endereçamento _integer_ e leitura síncrona.

```vhdl
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity romMif is

    generic
    (
        DATA_WIDTH : natural := 8;
        ADDR_WIDTH : natural := 8
    );

    port (
        clk: in std_logic;
        addr: in natural range 0 to 2**ADDR_WIDTH-1;
        q: out std_logic_vector (DATA_WIDTH-1 downto 0)
    );
end entity;

architecture inLineInitROM of romMif is

type memory_t is array (2**ADDR_WIDTH-1 downto 0) of std_logic_vector (DATA_WIDTH-1 downto 0);

    function init_rom
        return memory_t is
        variable tmp : memory_t := (others => (others => '0'));
        begin
        tmp(0) := x"49";
        tmp(1) := x"6e";
        tmp(2) := x"73";
        tmp(3) := x"70";
        tmp(4) := x"65";
        tmp(5) := x"72";
        tmp(6) := x"20";
        tmp(7) := x"21";
        return tmp;
    end init_rom;

signal content: memory_t := init_rom;

begin
    process(clk)
    begin
        if (RISING_EDGE(clk)) then
            q <= content(addr);
        end if;
    end process;
end architecture;

```
---->
</body>
</html>
